["^ ","~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$om.next.impl.parser","~:imports",null,"~:requires",["^ ","~$util","~$om.util","^8","^8"],"~:uses",null,"~:defs",["^ ","~$expr->ast",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","~:line",112,"~:column",7,"~:end-line",112,"~:end-column",16,"~:arglists",["~#list",["~$quote",["^D",[["~$x"]]]]],"~:doc","Given a query expression convert it into an AST."],"^3","~$om.next.impl.parser/expr->ast","~:variadic",false,"^>","js/om/next/impl/parser.cljc","^B",16,"~:method-params",["^D",[["~$x"]]],"~:protocol-impl",null,"~:arglists-meta",["^D",[null,null]],"^@",1,"^?",112,"^A",112,"~:max-fixed-arity",1,"~:fn-var",true,"^C",["^D",["^E",["^D",[["~$x"]]]]],"^F","Given a query expression convert it into an AST."],"~$call->ast",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",71,"^@",7,"^A",71,"^B",16,"^C",["^D",["^E",["^D",[[["~$f","~$args","~:as","~$call"]]]]]]],"^3","~$om.next.impl.parser/call->ast","^H",false,"^>","js/om/next/impl/parser.cljc","^B",16,"^I",["^D",[["~$p__29347"]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",71,"^A",71,"^L",1,"^M",true,"^C",["^D",["^E",["^D",[[["~$f","^O","^P","^Q"]]]]]]],"~$ast->expr",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",132,"^@",7,"^A",132,"^B",16,"^C",["^D",["^E",["^D",[["~$ast"],[["^ ","~:keys",["~$type","~$component"],"^P","^U"],"~$unparse?"]]]]],"^F","Given a query expression AST convert it back into a query expression.","~:top-fn",["^ ","^H",false,"^L",2,"^I",["^D",[["^U"],[["^ ","^V",["^W","^X"],"^P","^U"],"^Y"]]],"^C",["^D",[["^U"],[["^ ","^V",["^W","^X"],"^P","^U"],"^Y"]]],"^K",["^D",[null,null]]]],"^3","~$om.next.impl.parser/ast->expr","^H",false,"^>","js/om/next/impl/parser.cljc","^B",16,"^Z",["^ ","^H",false,"^L",2,"^I",["^D",[["^U"],[["^ ","^V",["^W","^X"],"^P","^U"],"^Y"]]],"^C",["^D",[["^U"],[["^ ","^V",["^W","^X"],"^P","^U"],"^Y"]]],"^K",["^D",[null,null]]],"^I",["^D",[["^U"],[["^ ","^V",["^W","^X"],"^P","^U"],"^Y"]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",132,"^A",132,"^L",2,"^M",true,"^C",["^D",[["^U"],[["^ ","^V",["^W","^X"],"^P","^U"],"^Y"]]],"^F","Given a query expression AST convert it back into a query expression."],"~$rethrow?",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",227,"^@",7,"^A",227,"^B",15,"^C",["^D",["^E",["^D",[["~$x"]]]]]],"^3","~$om.next.impl.parser/rethrow?","^H",false,"^>","js/om/next/impl/parser.cljc","^B",15,"^I",["^D",[["~$x"]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",227,"^A",227,"^L",1,"^M",true,"^C",["^D",["^E",["^D",[["~$x"]]]]]],"~$path-meta",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",163,"^@",7,"^A",163,"^B",16,"^C",["^D",["^E",["^D",[["~$data","~$path","~$query"],["^13","^14","^15","~$union-expr"]]]]],"^F","Add path metadata to a data structure. data is the data to be worked on.\n   path is the current path into the data. query is the query used to\n   walk the data. union-expr tracks the last seen union query to be used\n   when it finds a recursive union.","^Z",["^ ","^H",false,"^L",4,"^I",["^D",[["^13","^14","^15"],["^13","^14","^15","^16"]]],"^C",["^D",[["^13","^14","^15"],["^13","^14","^15","^16"]]],"^K",["^D",[null,null]]]],"^3","~$om.next.impl.parser/path-meta","^H",false,"^>","js/om/next/impl/parser.cljc","^B",16,"^Z",["^ ","^H",false,"^L",4,"^I",["^D",[["^13","^14","^15"],["^13","^14","^15","^16"]]],"^C",["^D",[["^13","^14","^15"],["^13","^14","^15","^16"]]],"^K",["^D",[null,null]]],"^I",["^D",[["^13","^14","^15"],["^13","^14","^15","^16"]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",163,"^A",163,"^L",4,"^M",true,"^C",["^D",[["^13","^14","^15"],["^13","^14","^15","^16"]]],"^F","Add path metadata to a data structure. data is the data to be worked on.\n   path is the current path into the data. query is the query used to\n   walk the data. union-expr tracks the last seen union query to be used\n   when it finds a recursive union."],"~$wrap-expr",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",125,"^@",7,"^A",125,"^B",16,"^C",["^D",["^E",["^D",[["~$root?","~$expr"]]]]]],"^3","~$om.next.impl.parser/wrap-expr","^H",false,"^>","js/om/next/impl/parser.cljc","^B",16,"^I",["^D",[["^19","^1:"]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",125,"^A",125,"^L",2,"^M",true,"^C",["^D",["^E",["^D",[["^19","^1:"]]]]]],"~$join->ast",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",88,"^@",7,"^A",88,"^B",16,"^C",["^D",["^E",["^D",[["~$join"]]]]]],"^3","~$om.next.impl.parser/join->ast","^H",false,"^>","js/om/next/impl/parser.cljc","^B",16,"^I",["^D",[["^1="]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",88,"^A",88,"^L",1,"^M",true,"^C",["^D",["^E",["^D",[["^1="]]]]]],"~$keyword->ast",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",51,"^@",7,"^A",51,"^B",19,"^C",["^D",["^E",["^D",[["~$k"]]]]]],"^3","~$om.next.impl.parser/keyword->ast","^H",false,"^>","js/om/next/impl/parser.cljc","^B",19,"^I",["^D",[["~$k"]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",51,"^A",51,"^L",1,"^M",true,"^C",["^D",["^E",["^D",[["~$k"]]]]]],"~$query->ast",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",78,"^@",7,"^A",78,"^B",17,"^C",["^D",["^E",["^D",[["^15"]]]]],"^F","Convert a query to its AST representation."],"^3","~$om.next.impl.parser/query->ast","^H",false,"^>","js/om/next/impl/parser.cljc","^B",17,"^I",["^D",[["^15"]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",78,"^A",78,"^L",1,"^M",true,"^C",["^D",["^E",["^D",[["^15"]]]]],"^F","Convert a query to its AST representation."],"~$ident->ast",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",107,"^@",7,"^A",107,"^B",17,"^C",["^D",["^E",["^D",[[["~$k","~$id","^P","~$ref"]]]]]]],"^3","~$om.next.impl.parser/ident->ast","^H",false,"^>","js/om/next/impl/parser.cljc","^B",17,"^I",["^D",[["~$p__29362"]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",107,"^A",107,"^L",1,"^M",true,"^C",["^D",["^E",["^D",[[["~$k","^1D","^P","^1E"]]]]]]],"~$dispatch",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",286,"^@",7,"^A",286,"^B",15,"^C",["^D",["^E",["^D",[["~$_","~$k","~$_"]]]]]],"^3","~$om.next.impl.parser/dispatch","^H",false,"^>","js/om/next/impl/parser.cljc","^B",15,"^I",["^D",[["~$_","~$k","~$_"]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",286,"^A",286,"^L",3,"^M",true,"^C",["^D",["^E",["^D",[["~$_","~$k","~$_"]]]]]],"~$union-entry->ast",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",56,"^@",7,"^A",56,"^B",23,"^C",["^D",["^E",["^D",[[["~$k","~$v"]]]]]]],"^3","~$om.next.impl.parser/union-entry->ast","^H",false,"^>","js/om/next/impl/parser.cljc","^B",23,"^I",["^D",[["~$p__29340"]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",56,"^A",56,"^L",1,"^M",true,"^C",["^D",["^E",["^D",[[["~$k","~$v"]]]]]]],"~$parser",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",231,"^@",7,"^A",231,"^B",13,"^C",["^D",["^E",["^D",[[["^ ","^V",["~$read","~$mutate"],"^P","~$config"]]]]]],"^F","Given a :read and/or :mutate function return a parser. Refer to om.next/parser\n   for top level documentation."],"^3","~$om.next.impl.parser/parser","^H",false,"^>","js/om/next/impl/parser.cljc","^B",13,"^I",["^D",[["~$p__29416"]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",231,"^A",231,"^L",1,"^M",true,"^C",["^D",["^E",["^D",[[["^ ","^V",["^1N","^1O"],"^P","^1P"]]]]]],"^F","Given a :read and/or :mutate function return a parser. Refer to om.next/parser\n   for top level documentation."],"~$symbol->ast",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",47,"^@",7,"^A",47,"^B",18,"^C",["^D",["^E",["^D",[["~$k"]]]]]],"^3","~$om.next.impl.parser/symbol->ast","^H",false,"^>","js/om/next/impl/parser.cljc","^B",18,"^I",["^D",[["~$k"]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",47,"^A",47,"^L",1,"^M",true,"^C",["^D",["^E",["^D",[["~$k"]]]]]],"~$union->ast",["^ ","^<",null,"^=",["^ ","^>","/home/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^?",66,"^@",7,"^A",66,"^B",17,"^C",["^D",["^E",["^D",[["~$m"]]]]]],"^3","~$om.next.impl.parser/union->ast","^H",false,"^>","js/om/next/impl/parser.cljc","^B",17,"^I",["^D",[["~$m"]]],"^J",null,"^K",["^D",[null,null]],"^@",1,"^?",66,"^A",66,"^L",1,"^M",true,"^C",["^D",["^E",["^D",[["~$m"]]]]]]],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^2",["~:query-root","~:path","~:remote","~:children","~:union-key","~:read","~:key","~:union-entry","~:else","~:call","~$*","~:value","~:params","~:ast","~:type","~:component","~:error/invalid-join","~:error/invalid-expression","~:om.next/abort","~:parser","~:root","~:result","~:prop","~:dispatch-key","~:om-path","~:action","~:target","^E","~:query","~:om.next/error","~:union","~$...","~:mutate","~:om.next/root","~:join","~:elide-paths"]],"~:order",["^2D","^24","^2;","^2C","^2<","^22","^2H","^21","^25","^2J","^E","^2G","^20","^29","^27","^2A","^1Z","^2N","^2K","^26","^2=","^2>","^2E","~$*","^2?","^23","^2L","^2O","^2@","^2M","^1[","^2:","^28","^2F","^2B","^2I"]],"^F","\n   Generic query expression parsing and AST manipulation.\n\n   QUERY EXPRESSIONS\n\n   Query expressions are a variation on Datomic Pull Syntax\n   http://docs.datomic.com/pull.html more suitable for generic client/server\n   state transfer. It's important to note the Om Next query expression syntax is\n   *not* a strict superset of Datomic Pull.\n\n   A query expression is composed of EDN values. The grammar for query\n   expressions follows:\n\n   QueryRoot    := EdnVector(QueryExpr*)\n   QueryExpr    := (EdnKeyword | IdentExpr | ParamExpr | JoinExpr)\n   IdentExpr    := EdnVector2(Keyword, EdnValue)\n   ParamExpr    := EdnList2(QueryExpr | EdnSymbol, ParamMapExpr)\n   ParamMapExpr := EdnMap(Keyword, EdnValue)\n   JoinExpr     := EdnMap((Keyword | IdentExpr), (QueryRoot | UnionExpr | RecurExpr))\n   UnionExpr    := EdnMap(Keyword, QueryRoot)\n   RecurExpr    := ('... | Integer)\n\n   Note most apis in Om Next expect a QueryRoot not a QueryExpr.\n\n   QUERY EXPRESSION AST FORMAT\n\n   Given a QueryExpr you can get the AST via om.next.impl.parser/expr->ast.\n   The following keys can appear in the AST representation:\n\n   {:type         (:prop | :join | :call | :root | :union | :union-entry)\n    :key          (EdnKeyword | EdnSymbol | IdentExpr)\n    :dispatch-key (EdnKeyword | EdnSymbol)\n    :union-key    EdnKeyword\n    :query        (QueryRoot | RecurExpr)\n    :params       ParamMapExpr\n    :children     EdnVector(AST)\n    :component    Object}\n\n   :query and :params may or may not appear. :type :call is only for\n   mutations."]
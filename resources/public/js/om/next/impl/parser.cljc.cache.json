["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",null,"~:name","~$om.next.impl.parser","~:imports",null,"~:requires",["^ ","~$util","~$om.util","^9","^9"],"~:uses",null,"~:defs",["^ ","~$expr->ast",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","~:line",112,"~:column",7,"~:end-line",112,"~:end-column",16,"~:arglists",["~#list",["~$quote",["^E",[["~$x"]]]]],"~:doc","Given a query expression convert it into an AST."],"^4","~$om.next.impl.parser/expr->ast","~:variadic",false,"^?","js/om/next/impl/parser.cljc","^C",16,"~:method-params",["^E",[["~$x"]]],"~:protocol-impl",null,"~:arglists-meta",["^E",[null,null]],"^A",1,"^@",112,"^B",112,"~:max-fixed-arity",1,"~:fn-var",true,"^D",["^E",["^F",["^E",[["~$x"]]]]],"^G","Given a query expression convert it into an AST."],"~$call->ast",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",71,"^A",7,"^B",71,"^C",16,"^D",["^E",["^F",["^E",[[["~$f","~$args","~:as","~$call"]]]]]]],"^4","~$om.next.impl.parser/call->ast","^I",false,"^?","js/om/next/impl/parser.cljc","^C",16,"^J",["^E",[["~$p__22982"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",71,"^B",71,"^M",1,"^N",true,"^D",["^E",["^F",["^E",[[["~$f","^P","^Q","^R"]]]]]]],"~$ast->expr",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",132,"^A",7,"^B",132,"^C",16,"^D",["^E",["^F",["^E",[["~$ast"],[["^ ","~:keys",["~$type","~$component"],"^Q","^V"],"~$unparse?"]]]]],"^G","Given a query expression AST convert it back into a query expression.","~:top-fn",["^ ","^I",false,"^M",2,"^J",["^E",[["^V"],[["^ ","^W",["^X","^Y"],"^Q","^V"],"^Z"]]],"^D",["^E",[["^V"],[["^ ","^W",["^X","^Y"],"^Q","^V"],"^Z"]]],"^L",["^E",[null,null]]]],"^4","~$om.next.impl.parser/ast->expr","^I",false,"^?","js/om/next/impl/parser.cljc","^C",16,"^[",["^ ","^I",false,"^M",2,"^J",["^E",[["^V"],[["^ ","^W",["^X","^Y"],"^Q","^V"],"^Z"]]],"^D",["^E",[["^V"],[["^ ","^W",["^X","^Y"],"^Q","^V"],"^Z"]]],"^L",["^E",[null,null]]],"^J",["^E",[["^V"],[["^ ","^W",["^X","^Y"],"^Q","^V"],"^Z"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",132,"^B",132,"^M",2,"^N",true,"^D",["^E",[["^V"],[["^ ","^W",["^X","^Y"],"^Q","^V"],"^Z"]]],"^G","Given a query expression AST convert it back into a query expression."],"~$rethrow?",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",227,"^A",7,"^B",227,"^C",15,"^D",["^E",["^F",["^E",[["~$x"]]]]]],"^4","~$om.next.impl.parser/rethrow?","^I",false,"^?","js/om/next/impl/parser.cljc","^C",15,"^J",["^E",[["~$x"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",227,"^B",227,"^M",1,"^N",true,"^D",["^E",["^F",["^E",[["~$x"]]]]]],"~$path-meta",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",163,"^A",7,"^B",163,"^C",16,"^D",["^E",["^F",["^E",[["~$data","~$path","~$query"],["^14","^15","^16","~$union-expr"]]]]],"^G","Add path metadata to a data structure. data is the data to be worked on.\n   path is the current path into the data. query is the query used to\n   walk the data. union-expr tracks the last seen union query to be used\n   when it finds a recursive union.","^[",["^ ","^I",false,"^M",4,"^J",["^E",[["^14","^15","^16"],["^14","^15","^16","^17"]]],"^D",["^E",[["^14","^15","^16"],["^14","^15","^16","^17"]]],"^L",["^E",[null,null]]]],"^4","~$om.next.impl.parser/path-meta","^I",false,"^?","js/om/next/impl/parser.cljc","^C",16,"^[",["^ ","^I",false,"^M",4,"^J",["^E",[["^14","^15","^16"],["^14","^15","^16","^17"]]],"^D",["^E",[["^14","^15","^16"],["^14","^15","^16","^17"]]],"^L",["^E",[null,null]]],"^J",["^E",[["^14","^15","^16"],["^14","^15","^16","^17"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",163,"^B",163,"^M",4,"^N",true,"^D",["^E",[["^14","^15","^16"],["^14","^15","^16","^17"]]],"^G","Add path metadata to a data structure. data is the data to be worked on.\n   path is the current path into the data. query is the query used to\n   walk the data. union-expr tracks the last seen union query to be used\n   when it finds a recursive union."],"~$wrap-expr",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",125,"^A",7,"^B",125,"^C",16,"^D",["^E",["^F",["^E",[["~$root?","~$expr"]]]]]],"^4","~$om.next.impl.parser/wrap-expr","^I",false,"^?","js/om/next/impl/parser.cljc","^C",16,"^J",["^E",[["^1:","^1;"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",125,"^B",125,"^M",2,"^N",true,"^D",["^E",["^F",["^E",[["^1:","^1;"]]]]]],"~$join->ast",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",88,"^A",7,"^B",88,"^C",16,"^D",["^E",["^F",["^E",[["~$join"]]]]]],"^4","~$om.next.impl.parser/join->ast","^I",false,"^?","js/om/next/impl/parser.cljc","^C",16,"^J",["^E",[["^1>"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",88,"^B",88,"^M",1,"^N",true,"^D",["^E",["^F",["^E",[["^1>"]]]]]],"~$keyword->ast",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",51,"^A",7,"^B",51,"^C",19,"^D",["^E",["^F",["^E",[["~$k"]]]]]],"^4","~$om.next.impl.parser/keyword->ast","^I",false,"^?","js/om/next/impl/parser.cljc","^C",19,"^J",["^E",[["~$k"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",51,"^B",51,"^M",1,"^N",true,"^D",["^E",["^F",["^E",[["~$k"]]]]]],"~$query->ast",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",78,"^A",7,"^B",78,"^C",17,"^D",["^E",["^F",["^E",[["^16"]]]]],"^G","Convert a query to its AST representation."],"^4","~$om.next.impl.parser/query->ast","^I",false,"^?","js/om/next/impl/parser.cljc","^C",17,"^J",["^E",[["^16"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",78,"^B",78,"^M",1,"^N",true,"^D",["^E",["^F",["^E",[["^16"]]]]],"^G","Convert a query to its AST representation."],"~$ident->ast",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",107,"^A",7,"^B",107,"^C",17,"^D",["^E",["^F",["^E",[[["~$k","~$id","^Q","~$ref"]]]]]]],"^4","~$om.next.impl.parser/ident->ast","^I",false,"^?","js/om/next/impl/parser.cljc","^C",17,"^J",["^E",[["~$p__22997"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",107,"^B",107,"^M",1,"^N",true,"^D",["^E",["^F",["^E",[[["~$k","^1E","^Q","^1F"]]]]]]],"~$dispatch",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",286,"^A",7,"^B",286,"^C",15,"^D",["^E",["^F",["^E",[["~$_","~$k","~$_"]]]]]],"^4","~$om.next.impl.parser/dispatch","^I",false,"^?","js/om/next/impl/parser.cljc","^C",15,"^J",["^E",[["~$_","~$k","~$_"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",286,"^B",286,"^M",3,"^N",true,"^D",["^E",["^F",["^E",[["~$_","~$k","~$_"]]]]]],"~$union-entry->ast",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",56,"^A",7,"^B",56,"^C",23,"^D",["^E",["^F",["^E",[[["~$k","~$v"]]]]]]],"^4","~$om.next.impl.parser/union-entry->ast","^I",false,"^?","js/om/next/impl/parser.cljc","^C",23,"^J",["^E",[["~$p__22975"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",56,"^B",56,"^M",1,"^N",true,"^D",["^E",["^F",["^E",[[["~$k","~$v"]]]]]]],"~$parser",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",231,"^A",7,"^B",231,"^C",13,"^D",["^E",["^F",["^E",[[["^ ","^W",["~$read","~$mutate"],"^Q","~$config"]]]]]],"^G","Given a :read and/or :mutate function return a parser. Refer to om.next/parser\n   for top level documentation."],"^4","~$om.next.impl.parser/parser","^I",false,"^?","js/om/next/impl/parser.cljc","^C",13,"^J",["^E",[["~$p__23051"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",231,"^B",231,"^M",1,"^N",true,"^D",["^E",["^F",["^E",[[["^ ","^W",["^1O","^1P"],"^Q","^1Q"]]]]]],"^G","Given a :read and/or :mutate function return a parser. Refer to om.next/parser\n   for top level documentation."],"~$symbol->ast",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",47,"^A",7,"^B",47,"^C",18,"^D",["^E",["^F",["^E",[["~$k"]]]]]],"^4","~$om.next.impl.parser/symbol->ast","^I",false,"^?","js/om/next/impl/parser.cljc","^C",18,"^J",["^E",[["~$k"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",47,"^B",47,"^M",1,"^N",true,"^D",["^E",["^F",["^E",[["~$k"]]]]]],"~$union->ast",["^ ","^=",null,"^>",["^ ","^?","/Users/xuelin/dev/cloudxmark/resources/public/js/om/next/impl/parser.cljc","^@",66,"^A",7,"^B",66,"^C",17,"^D",["^E",["^F",["^E",[["~$m"]]]]]],"^4","~$om.next.impl.parser/union->ast","^I",false,"^?","js/om/next/impl/parser.cljc","^C",17,"^J",["^E",[["~$m"]]],"^K",null,"^L",["^E",[null,null]],"^A",1,"^@",66,"^B",66,"^M",1,"^N",true,"^D",["^E",["^F",["^E",[["~$m"]]]]]]],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["~#set",["~:query-root","~:path","~:remote","~:children","~:union-key","~:read","~:key","~:union-entry","~:else","~:call","~$*","~:value","~:params","~:ast","~:type","~:component","~:error/invalid-join","~:error/invalid-expression","~:om.next/abort","~:parser","~:root","~:result","~:prop","~:dispatch-key","~:om-path","~:action","~:target","^F","~:query","~:om.next/error","~:union","~$...","~:mutate","~:om.next/root","~:join","~:elide-paths"]],"~:order",["^2F","^26","^2=","^2E","^2>","^24","^2J","^23","^27","^2L","^F","^2I","^22","^2;","^29","^2C","^20","^2P","^2M","^28","^2?","^2@","^2G","~$*","^2A","^25","^2N","^2Q","^2B","^2O","^21","^2<","^2:","^2H","^2D","^2K"]],"^G","\n   Generic query expression parsing and AST manipulation.\n\n   QUERY EXPRESSIONS\n\n   Query expressions are a variation on Datomic Pull Syntax\n   http://docs.datomic.com/pull.html more suitable for generic client/server\n   state transfer. It's important to note the Om Next query expression syntax is\n   *not* a strict superset of Datomic Pull.\n\n   A query expression is composed of EDN values. The grammar for query\n   expressions follows:\n\n   QueryRoot    := EdnVector(QueryExpr*)\n   QueryExpr    := (EdnKeyword | IdentExpr | ParamExpr | JoinExpr)\n   IdentExpr    := EdnVector2(Keyword, EdnValue)\n   ParamExpr    := EdnList2(QueryExpr | EdnSymbol, ParamMapExpr)\n   ParamMapExpr := EdnMap(Keyword, EdnValue)\n   JoinExpr     := EdnMap((Keyword | IdentExpr), (QueryRoot | UnionExpr | RecurExpr))\n   UnionExpr    := EdnMap(Keyword, QueryRoot)\n   RecurExpr    := ('... | Integer)\n\n   Note most apis in Om Next expect a QueryRoot not a QueryExpr.\n\n   QUERY EXPRESSION AST FORMAT\n\n   Given a QueryExpr you can get the AST via om.next.impl.parser/expr->ast.\n   The following keys can appear in the AST representation:\n\n   {:type         (:prop | :join | :call | :root | :union | :union-entry)\n    :key          (EdnKeyword | EdnSymbol | IdentExpr)\n    :dispatch-key (EdnKeyword | EdnSymbol)\n    :union-key    EdnKeyword\n    :query        (QueryRoot | RecurExpr)\n    :params       ParamMapExpr\n    :children     EdnVector(AST)\n    :component    Object}\n\n   :query and :params may or may not appear. :type :call is only for\n   mutations."]